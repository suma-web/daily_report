# 取り組んだ課題一覧
- Reactの公式チュートリアルをやる 修了
- モダンJavaScriptの基礎から始める挫折しないためのReact入門（素のJavaScriptでTODOリストを作る　まで）

# 感じたこと
- 特になし

# 次やること
- モダンJavaScriptの基礎から始める挫折しないためのReact入門　修了
- Reactに入門した人のためのもっとReactが楽しくなるステップアップコース完全版　着手

# わかったこと
- React にとって重要なのは JSX マークアップの位置ではなく UI ツリー内の位置である
- デューサの中では switch 文を使うことが一般的。
- リデューサなど通常の state 更新は`push`メソッドを使わない。
    - Immer は内部でdraft に加えたミューテーションが適用された **state のコピーを自動作成**するので`push`メソッドを使用してもよい。
- コンテクストにより、コンポーネントがそれ以下のツリー全体に情報を提供できる
    - `export const MyContext = createContext(defaultValue) `を使用して作成およびエクスポートする。
    - フックに `useContext(MyContext)` のようにコンテクストを渡せば、どんな深い子コンポーネントからも値が読み取れる。
    - コンテクストの値を提供するには子要素を `<MyContext value={...}>` でラップする。
- コンポーネントに情報を「記憶」させたいが、その情報が新しいレンダーをトリガしないようにしたい場合、`ref` を使う。
    - `import { useRef } from 'react';`
- 通常、`ref` を使用するのは、コンポーネントが React の外に「踏み出して」、外部 APIと通信する必要がある場合。
- `ref.current.focus()`で「そのDOM要素にフォーカスを当てる」
- エフェクトを使って動機を行う。`import { useEffect } from 'react';`
```
useEffect(() => {
    //レンダー後にuseEffect内のコードが実行
  });

```
```
useEffect(fn)       => 毎回レンダー後 実行
useEffect(fn, [])   => 初回のみ 実行
useEffect(fn, [x])  => xが変わったとき 実行
```
- 既存の props や state から計算できるものは、state に入れない。
- 重たい計算をキャッシュするには、useEffect の代わりに useMemo を追加する。
- エフェクトのコードで使用されるすべてのリアクティブな値は、依存値のリスト内で宣言されなければなりません。依存配列は、その周囲にあるコードによって決定されます。
- `要素.closest(" 探したい親要素 ")`メソッドは親要素を探す。

# 学習時間
7h