# 取り組んだ課題一覧
- JavaScript
    - 【JS】ガチで学びたい人のためのJavaScriptメカニズム（Udemy全視聴）
    - 鬼滅の刃のキャラクター一覧を取得するAPIを叩く（設計）
        - htmlはレイアウトまで、jsはjsonファイルを`fetch`メソッドでそれぞれのカテゴリーのurlを読み込み成功まで

# 感じたこと
- 鬼滅APIは今日のUdemy動画のほとんどの内容を使うと推測できる。
- htmlに一覧を表示できるようためにどう実装するかを次に考えたい。

# 次やること
- 鬼滅の刃のキャラクター一覧を取得するAPIを叩く（実装）
    - htmlに全キャラクターの一覧を表示させる

# わかったこと

一連の処理を「スレッド」と言う。
非同期処理は一時的にメインスレッドから処理が切り離される。
非同期APIはsetTimeout、Promiseなど

タスクキュー
- Await/Async 
    - Promiseをさらに直感的に記述できるようにしたもの
    - Async はPromiseを返却する。関数の宣言を行う。Await はPromiseを返却する関数の非同期処理が完了するまで待つ。
 
- JSONファイルの特徴
    - シングルクォーテーションで表記できない。必ずダブル。プロパティもダブルをつける。
- (widow).fetch(‘ファイル名’)を使い、JSONのデータを取得し、加工するやり方が一般的。
- どちらも同じ結果になる。
```
fetch('users.json').then(function(response) {
   console.log(response.json());
   return response.json();
}).then(function(json) {
   console.log(json);
   for(const user of json) {
      console.log(`I'm ${user.name}, ${user.age} years old`)
   }
 })

async function fetchUsers() {
  const response = await fetch('users.json');
  const json = await response.json();    //json()メソッドを使用する
  for(const user of json) {
    console.log(`I'm ${user.name}, ${user.age} years old`)
  }
}
```
- 大規模開発では、throwを切り離して使用することがある。
- export default の場合、変数などは何もなくていい。import先では、{}内に挿入しなくて良い。そして変数名を任意で決められる。他は{}でimportする
- モジュールコンテキストではthisは使えない
- `defer` はscriptのモジュールを非同期処理にしてくれる。モジュールに対応していないブラウザにはnomoduleをつける
- ’use strict’は予期しないエラーを防ぐ
- ダイナミックインポート（必要な時にインポートされるように設定）
```
import（’ファイル名’）.then((modules)=>{
　console.log(modules);
　modules.publicFn();
})
→asyncやawaitでも実現可能
```
- reflectとは
    - 内部メソッドを呼び出す関数の格納場所
    - Proxyと合わせて使用するため
    - 演算子などを用いて表記したところを関数表記にできる
```
class C {
	constructor(a, b) {
		this.a = a;
		this.b = b;
	}
}

const obj1 = new C(1, 2);   //演算子などを用いて表記
console.log(obj1);

const obj2 = Reflect.construct(C, [1,2]);   //関数表記
console.log(obj2);
```
- コールバックするときに演算子などを用いて表記する場合は、一度関数化しなければいけない
- JSON.parseはJSONファイルからObjectを生成。JSON.stringifyはObjectからJSONファイルを生成。JSONは文字列。

# 学習時間
7h